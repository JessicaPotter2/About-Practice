通过setAttribute（）方法对文档做出的修改，将使得文档在浏览器窗口里的显示效果和/行为动作发生相应的变化，但我们查看源代码是仍然是原来是属性值，即setAttribute（）方法做出的修改不会反应在文档本身的源代码里。但是在控制台看到的是已经修改后的属性。DOM的工作模式：先加载文档的静态内容，再以动态方式对他们进行刷新，动态刷新不影响文档的静态内容。对页面内容的刷新不需要最终用户在他们的浏览器里执行页面刷新操作就可以实现。
元素节点的nodeType属性值是1，属性节点的nodeType属性值是2，文本节点的nodeType属性值是3.
注意应该只在有绝对必要的情况下才使用弹出窗口，因为这将牵涉到网页的可访问性问题，如果网页上的某个链接将弹出新窗口，最好在这个链接本身的文字中予以说明。
DOM脚本编程工作有关问题：预留退路，向后兼容性，分离JavaScript。
把HTML文档内容与JavaScript代码所实现的操作行为分离开很重要，如果想用JavaScript给某个网页添加一些行为，就不应该让JavaScript代码对这个网页的结构有任何依赖。
结构化程序设计（structed programming）理论提出这样一条原则：每个函数应该只有一个入口点和一个出口点。同一个函数有多个出口点的情况时可以接受的，但前提是它们应该集中出现在这个函数的开头部分。
保留字和现有的JavaScript函数或方法的名字不能用来命名变量。
links[i].onclick=function(){}这条语句定义了一个匿名函数，适合定义在整个脚本里只出现一次的函数，匿名函数没有名字，只能在哪里定义，在哪里使用。
每个事件处理函数只能绑定一条指令；如：window.onload=firstFunction();window.onload=secondFunction;secondFunction将取代firstFunction。可以这样写：window.onload=function(){firstFunction();secondFunction();}也可已使用addLoadEvent();函数addLoadEvent();:
/*addLoadEvent()函数，把函数绑定到window.onload事件上*/
		function addLoadEvent(func){
			var oldonload=window.onload;
			if(typeof window.onload!='function'){
				window.onload=func;
			}else{
				window.onload=function(){
					oldonload();
					func();
				}
			}
		}
		addLoadEvent(firstFunction);
		addLoadEvent(secondFunction);
三元操作符：？   variable=condition?if true:if false;
nodeName属性总是返回一个大写字母的值，即使元素在HTML文档里是小写字母。
脚本绝不应该对HTML文档的内容和结构做太多假设。
HTML-DOM记号通常比较剪短，但他们只能用来处理Web文档。
MIME类型application/xhtml+xml与document.write()方法不兼容，浏览器在呈现这种XHTML文档时根本不会执行document.write()方法。
innerHTML属性也只适用于HTML文档。浏览器在呈现正宗的XHTML文档（即MIME类型是application/xhtml+xml的XHTML文档）时不会去执行innerHTML属性。
innerHTML会覆盖原先的HTML内容。
以动态方式实时创建HTML内容：我们不是在创建HTML内容，而是在改变DOM节点树。根据DOM，一个文档就是一颗节点树，如果想在节点树上添加内容，就必须插入新的节点。如果像把一些HTML内容添加到文档里，就必须在相应的DOM节点树上插入元素节点。
createElement（）方法创建元素节点，createTextNode创建文本节点。
parentElement.insertBefore(newElement,targetElement)
即使某种特定的浏览器会引起问题，也没有必要使用浏览器嗅探代码，对浏览器的名称和版本号进行嗅探的办法很难做到面面俱到，而且往往会导致非常复杂难解的代码。
JavaScript脚本只应该用来充实文档的内容，要避免使用DOM技术来直接插入核心内容。
